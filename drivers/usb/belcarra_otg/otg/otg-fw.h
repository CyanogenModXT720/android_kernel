
/* Generated by otg-h.awk
 *
 * Do not Edit, see otg-state.awk
 */

/* %Z %K */


/*!
* @defgroup OTGFW Firmware
* @ingroup onthegogroup
*/

/*!
* @file otg/otg/otg-fw.h
* @brief OTG Firmware - Input, Output and Timeout definitions
* This file defines the OTG State Machine input, output and timeout constants.
*
*
* @ingroup OTGFW
*/

/*!
* @name OTGFW
* @section OTGFW_SECTION - otg-fw.h
*/

/*!
* @name OTGVERSION OTG Version
* Version information
* @{
*/

#define OTG_VERSION_FW 200710031619L

/*! @} */

/*!
* @name BASIC
* These are the provided for application layer compatibility.
* @{
*/
#ifdef OTG_APPLICATION
typedef unsigned char u8;
typedef unsigned short u16;
typedef unsigned long u32;
typedef unsigned long long u64;
#include <stdio.h>
#include <sys/ioctl.h>
#endif                          /* OTG_APPLICATION */

/*! @} */

/*!
* @name OTGSTRUCT OTG Structures
* Basic OTG Structures
*/
#define OTGADMIN_MAXSTR      48

/*!
 * @struct otg_test
 * 
 * This defines the tests that allow the state machine to move
 * from state to state based on input events.
 * 
 *  Goto target: if (                               
 *              (!test1 || (test1 & inputs)) && 
 *              (!test2 || (test2 & inputs)) && 
 * 
 */
typedef struct otg_test {
        u16             test;   /*!< Test number */
        u16             state;  /*!< State Machine State */
        u32             target; /*!< Goto this target if             */
        u64             test1;  /*!< (!test1 || (test1 & inputs)) && */
        u64             test2;  /*!< (!test2 || (test2 & inputs)) && */
        u64             test3;  /*!< (!test3 || (test3 & inputs)) && */
        /* N.B. An empty test is ignored.    */
} otg_test_t;                   /*!<                                 */


/*!
 * @struct otg_input_name
 * This structure simply allows for a table of input names that can
 * searched for by input mask
 */
typedef struct otg_input_name {
        u32             value;  /*!< Bit value */
        char            name[OTGADMIN_MAXSTR];  /*!< Name of state. */
} otg_input_name_t;


/*!
 * @struct otg_state
 * This defines an OTG State. Each state has a name, meta state,
 * timeout, reset and outputs
 * 
 * On entry to the state the reset mask is or'd into the current 
 * input mask, the settings defined in the output mask are used to.
 * call the required output functions and then if present the timer
 * is started with the timeout value (in uSec).
 * 
 */
typedef struct otg_state {
        u16             state;  /*!< State Machine State */
        u16             meta;   /*!< Meta Machine State */
        char            name[OTGADMIN_MAXSTR];  /*!< Name of state. */
        u32             tmout;  /*!< Start timeout if non-zero */
        u64             reset;  /*!< Or these inputs on entry to state */
        u64             outputs;        /*!< Or these outputs on entry to state */
} otg_state_t;


/*!
 * @struct otg_ioctl_name
 * This structure allows a table for a table of IOCTL event names that can be
 * searched for by the ioctl command value. It also stores the actual
 * input mask to set or reset when according to the ioctl arguement.
 */
typedef struct otg_ioctl_name {
        u32             cmd;    /*!< Ioctl cmd */
        u32             set;    /*!< Signal to set/reset */
        char           *name;   /*!< Name of ioctl. */
} otg_ioctl_name_t;


/*!
 * @struct otg_admin_command
 * This allows for a table of IOCTL admin commands.
 */
typedef struct otg_admin_command {
        int             n;      /*!< Ioctl cmd */
        char            string[OTGADMIN_MAXSTR];        /*!< Signal to set/reset */
        unsigned short  vid;
        unsigned short  pid;
        unsigned char   cdrom;
} otg_admin_command_t;


/*!
 * @struct otg_status_update
 * This is used by the OTG administrative programs to pass data to and received
 * data from the OTG State Machine driver.
 */
typedef struct otg_status_update {
        u16             state;  /*!< current state */
        u16             meta;   /*!< current meta state */
        u32             inputs; /*!< current inputs */
        u64             outputs;        /*!< current outputs */
        u32             capabilities;   /*!<  */
        char            fw_name[OTGADMIN_MAXSTR];       /*!< name of firmware */
        char            state_name[OTGADMIN_MAXSTR];    /*!< name of current state */
        char            meta_name[OTGADMIN_MAXSTR];     /*!< name of current meta-state */
        char            function_name[OTGADMIN_MAXSTR]; /*!< currently selected function */
} otg_status_update_t;


/*!
 * @struct otg_firmware_info
 * This is used by the OTG Administrative program to pass firmware information
 * to the OTG State Machine./
 */
typedef struct otg_firmware_info {
        int             number_of_states;       /*!< number of states */
        int             number_of_tests;        /*!< number of tests */
        char            fw_name[OTGADMIN_MAXSTR];       /*!< name of firmware */
} otg_firmware_info_t;


/*!
 * @struct otg_firmware
 * This is used by the OTG Administrative program to pass firmware
 * to the OTG State Machine./
 */
typedef struct otg_firmware {
        int             number_of_states;       /*!< number of states */
        int             number_of_tests;        /*!< number of tests */
        char            fw_name[OTGADMIN_MAXSTR];       /*!< name of firmware */
        struct otg_state *otg_states;   /*!< output information */
        struct otg_test *otg_tests;     /*!< test information */
} otg_firmware_t;

/*! @} */

/*!
* @name OTGTIME Time Macros
* Basic OTG Time Macros
*/

#define US(n)                   (n)              /*!< micro-seconds */

#define MS(n)                   (1000 * US(n))   /*!< milli-seconds */

#define SEC(n)                  (1000 * MS(n))   /*!< seconds */

/*! @} */

/*!
* @name OTGOUTPUTM Output Macros
* OTG Output Macros
*/

/* OTG State Outputs
 *
 * Each state that we transition to defines new settings for each of the defined
 * outputs. Each output setting can have four settings:
 *
 *      
 *      
 *      
 *      
 */
#define NC      ((u64)0x0)                       /*!< NC      no change */
#define SET     ((u64)0x1)                       /*!< SET     the output should be set (i.e. enabled) */
#define RESET   ((u64)0x2)                       /*!< RESET   the output should be reset (i.e. disabled) */
#define PULSE   ((u64)0x3)                       /*!< OTHER   special setting, for example used for pulse vbus */
#define POWER   ((u64)0x3)                       /*!< POWER   */

#define _MASK(n)                (((u64) 1) << n) /*!< Set nth bit in 64 bit mask */
#define _NOT(m)                 (((u64) m) << 32)       /*!< Shift left mask 32 bits */
#define _ncmask(n)              (NC)             /*!< No output change mask */
#define _setmask(n)             (SET << (n*2))   /*!< Output set mask */
#define _resetmask(n)           (RESET << (n*2)) /*!< Output reset mask */
#define _pulsemask(n)           (PULSE << (n*2)) /*!< Output pulse mask */
#define _powermask(n)           (POWER << (n*2)) /*!< Output poser mask */

/*! @} */

/*!
* @name OTGNAMES OTG Names
* Basic OTG Name Tables
*/

extern struct otg_input_name otg_input_names[];
extern struct otg_ioctl_name otg_ioctl_names[];
extern struct otg_firmware *otg_firmware_loaded;
extern char    *otg_output_names[];


/*! @} */

/* Generated by otg-inputs-h.awk
 *
 * Do not Edit this file.
 */

/* %Z %K */


 /*!
  * N.B. The OTG State Machine Documentation uses the syntax A and A/
  * to indicate an event being true or not true. Because a trailing
  * slash is not legal in C we use A and A_ to indicate true and not true.
  */

 /*!
  * @name OTG Transceiver Inputs
  * These inputs reflect changes seen in the OTG Transceiver. These
  * what are available in most common OTG transceivers, for example
  * the ISP1301 or MAX3353.
  *
  * The following are typical Vbus comparators.
  *
  * ......................................ISP1301.........MAX3353E
  * B-Session.end.threshold...............0.2V-0.8V.......0.5V....
  * Session.Valid.Comparator..............0.8V-2.0V.......1.4V....
  * B-Session.Valid.......................2.0V-4.0V.......N/A.....
  * A-Device.Vbus.Valid.Comparator........4.4V............4.6V....
  *
  * @{
  */
#define ID_GND                         _MASK( 0) /*!< otg_ok -    ID is grounded */
#define ID_GND_                        _NOT(ID_GND)
#define ID_FLOAT                       _MASK( 1) /*!< otg_ok -    ID is floating */
#define ID_FLOAT_                      _NOT(ID_FLOAT)
#define DP_HIGH                        _MASK( 2) /*!< otg_ok -    DP is pulled high */
#define DP_HIGH_                       _NOT(DP_HIGH)
#define DM_HIGH                        _MASK( 3) /*!< otg_ok -    DM pullup is pulled high */
#define DM_HIGH_                       _NOT(DM_HIGH)
#define B_SESS_END                     _MASK( 4) /*!< otg_ok -    Vbus less than B-Session end thresshold */
#define B_SESS_END_                    _NOT(B_SESS_END)
#define A_SESS_VLD                     _MASK( 5) /*!< otg_ok -    Vbus greater than Session valid threshold */
#define A_SESS_VLD_                    _NOT(A_SESS_VLD)
#define B_SESS_VLD                     _MASK( 6) /*!< otg_ok -    Vbus greater than B-Session Valid threshold */
#define B_SESS_VLD_                    _NOT(B_SESS_VLD)
#define VBUS_VLD                       _MASK( 7) /*!< otg_ok -    Vbus greater than A-Device Vbus Valid threshold */
#define VBUS_VLD_                      _NOT(VBUS_VLD)
#define SRP_DET                        _MASK( 8) /*!< a_idle -    SRP Detected (Vbus pulsed) */
#define SRP_DET_                       _NOT(SRP_DET)
#define SE0_DET                        _MASK( 9) /*!< b_idle -    SE0 Detected (Single Ended Zeros, DM and DP both low) */
#define SE0_DET_                       _NOT(SE0_DET)
#define SE1_DET                        _MASK(10) /*!< b_idle -    SE1 Detected (Single Ended Ones, DM and DP both high) */
#define SE1_DET_                       _NOT(SE1_DET)
#define BDIS_ACON                      _MASK(10) /*!< a_hnp_wait -    Auto DP pullup high after B-disconnect */
#define BDIS_ACON_                     _NOT(BDIS_ACON)
#define CR_INT_DET                     _MASK(10) /*!< ph_audio -    0.4V < DP < 0.6V */
#define CR_INT_DET_                    _NOT(CR_INT_DET)
 /* @} */
 /*!
  * @name Peripheral and Host driver signals.
  *
  *
  * @{
  */
#define HUB_PORT_CONNECT               _MASK(11) /*!< otg_both -    Port Connection */
#define HUB_PORT_CONNECT_              _NOT(HUB_PORT_CONNECT)
#define BUS_RESET                      _MASK(12) /*!< otg_both -    Bus has reset. */
#define BUS_RESET_                     _NOT(BUS_RESET)
#define ADDRESSED                      _MASK(13) /*!< otg_both -    Device has been addressed (received SET ADDRESS request.) */
#define ADDRESSED_                     _NOT(ADDRESSED)
#define DEVICE_REQUEST                 _MASK(14) /*!< otg_both -    Device has received device request (received SETUP request.) */
#define DEVICE_REQUEST_                _NOT(DEVICE_REQUEST)
#define CONFIGURED                     _MASK(15) /*!< otg_both -    Device has been configured (received SET CONFIG request.) */
#define CONFIGURED_                    _NOT(CONFIGURED)
#define NOT_SUPPORTED                  _MASK(16) /*!< otg_both -    Peripheral not supported (no class driver.) */
#define NOT_SUPPORTED_                 _NOT(NOT_SUPPORTED)
#define BUS_SUSPENDED                  _MASK(17) /*!< otg_both -    Bus has been suspended. */
#define BUS_SUSPENDED_                 _NOT(BUS_SUSPENDED)
 /* @} */

 /*!
  * @name Administrative Policy Inputs
  * These are only valid in the state indicated and
  * can be enabled or disabled.
  *
  * @{
  */
#define a_bcon_no_tmout_req            _MASK(18) /*!< otg_host -    Application on A-host wants Ta_wait_bcon timeout disabled (non-OTG mode). */
#define a_bcon_no_tmout_req_           _NOT(a_bcon_no_tmout_req)
#define a_hpwr_req                     _MASK(19) /*!< otg_host -    Application on A-host wants external charge pump enabled. */
#define a_hpwr_req_                    _NOT(a_hpwr_req)
#define bus_drop                       _MASK(20) /*!< otg_ok -    Application on Device needs to power down bus. */
#define bus_drop_                      _NOT(bus_drop)
#define a_bus_drop                     _MASK(20) /*!< otg_ok -    Application on A-Device needs to power down bus. */
#define a_bus_drop_                    _NOT(a_bus_drop)
#define b_bus_drop                     _MASK(20) /*!< otg_ok -    Application on B-Device needs to disconnect from bus. */
#define b_bus_drop_                    _NOT(b_bus_drop)
#define bus_req                        _MASK(21) /*!< otg_ok -    Application on Device wants to use the bus. */
#define bus_req_                       _NOT(bus_req)
#define a_bus_req                      _MASK(21) /*!< otg_ok -    Application on A-Device wants to act as host */
#define a_bus_req_                     _NOT(a_bus_req)
#define b_bus_req                      _MASK(21) /*!< otg_ok -    Application on B-Device wants to act as host */
#define b_bus_req_                     _NOT(b_bus_req)
#define b_sess_req                     _MASK(21) /*!< otg_ok -    Application on B-Device to perform SRP (alias for b_srp_req.) */
#define b_sess_req_                    _NOT(b_sess_req)
#define suspend_req                    _MASK(22) /*!< otg_host -    Application on Device requests bus be suspended (alias for a_bus_req/.) */
#define suspend_req_                   _NOT(suspend_req)
#define a_suspend_req                  _MASK(22) /*!< otg_host -    Application on A-host requests bus be suspended (alias for a_bus_req/.) */
#define a_suspend_req_                 _NOT(a_suspend_req)
#define b_suspend_req                  _MASK(22) /*!< otg_host -    Application on B-host requests bus be suspended (alias for b_bus_req/.) */
#define b_suspend_req_                 _NOT(b_suspend_req)
 /* @} */

 /*!
  * @name Administrative Action Inputs
  * These are only valid in state indicated. The
  * state machine tests must reset in states
  * prior and after use.
  * @{
  */
#define set_remote_wakeup_cmd          _MASK(23) /*!< a_host -    A-Device will send Remote Wakeup Enable Request */
#define set_remote_wakeup_cmd_         _NOT(set_remote_wakeup_cmd)
#define remote_wakeup_cmd              _MASK(23) /*!< tr_configured -    B-Device will perform Remote Wakeup. */
#define remote_wakeup_cmd_             _NOT(remote_wakeup_cmd)
#define reset_remote_wakeup_cmd        _MASK(24) /*!< a_host -    A-Device will send Remote Wakeup Disable Request */
#define reset_remote_wakeup_cmd_       _NOT(reset_remote_wakeup_cmd)
#define clr_err_cmd                    _MASK(24) /*!< a_vbus_err -    A-Device ill clears Vbus overcurrent error. */
#define clr_err_cmd_                   _NOT(clr_err_cmd)
#define b_hnp_cmd                      _MASK(24) /*!< b_configured -    B-Device will attempt HNP */
#define b_hnp_cmd_                     _NOT(b_hnp_cmd)
#define ph_int_cmd                     _MASK(24) /*!< ph_audio -    B-Device will request Carkit interrupt */
#define ph_int_cmd_                    _NOT(ph_int_cmd)
#define ph_audio_cmd                   _MASK(24) /*!< ph_uart -    Application on B-Device connected to Carkit requests audio mode. */
#define ph_audio_cmd_                  _NOT(ph_audio_cmd)
#define cr_int_cmd                     _MASK(24) /*!< cr_aud -    Application on A-Device wants to emulate Carkit */
#define cr_int_cmd_                    _NOT(cr_int_cmd)
#define led_on_cmd                     _MASK(25) /*!< ph_uart -    B-Device will enable Carkit LED */
#define led_on_cmd_                    _NOT(led_on_cmd)
#define led_off_cmd                    _MASK(26) /*!< ph_uart -    B-Device will disable Carkit LED */
#define led_off_cmd_                   _NOT(led_off_cmd)
 /* @} */

 /*!
  * @name Internal State
  * Used to track status changes.
  * @{
  */
#define HNP_ENABLED                    _MASK(26) /*!< b_configured -    B-HNP Enable Request sent (a-host) or received (b-peripheral). */
#define HNP_ENABLED_                   _NOT(HNP_ENABLED)
#define HNP_CAPABLE                    _MASK(27) /*!< otg_both -    B-host Peripheral may do HNP */
#define HNP_CAPABLE_                   _NOT(HNP_CAPABLE)
#define HNP_SUPPORTED                  _MASK(27) /*!< otg_both -    B-host can do HNP (A-Host Received HNP Supported SET FEATURE) */
#define HNP_SUPPORTED_                 _NOT(HNP_SUPPORTED)
#define REMOTE_WAKEUP_ENABLED          _MASK(28) /*!< otg_configured -    Remote Wakeup Enable Request received. */
#define REMOTE_WAKEUP_ENABLED_         _NOT(REMOTE_WAKEUP_ENABLED)
#define REMOTE_CAPABLE                 _MASK(28) /*!< otg_both -    Peripheral can do remote wakeup */
#define REMOTE_CAPABLE_                _NOT(REMOTE_CAPABLE)
 /* @} */

 /*!
  * @name Global Administration
  * @{
  */
 /* @} */

 /*!
  * @name Driver Initialization Finished signals
  * @{
  */
#define PCD_OK                         _MASK(29) /*!< otg_driver -    PCD Driver Initialization Finished. */
#define PCD_OK_                        _NOT(PCD_OK)
#define TCD_OK                         _MASK(29) /*!< otg_driver -    TCD Driver Initialization Finished. */
#define TCD_OK_                        _NOT(TCD_OK)
#define HCD_OK                         _MASK(29) /*!< otg_driver -    HCD Driver Initialization Finished. */
#define HCD_OK_                        _NOT(HCD_OK)
#define OCD_OK                         _MASK(29) /*!< otg_driver -    OCD Driver Initialization Finished. */
#define OCD_OK_                        _NOT(OCD_OK)
 /* @} */

 /*!
  * @name Timeout and enable
  * @{
  */
#define TMOUT                          _MASK(30) /*!< otg_all -    Generic Timeout */
#define TMOUT_                         _NOT(TMOUT)
#define enable_otg                     _MASK(31) /*!< otg_all -    Move State Machine otg_disabled state. */
#define enable_otg_                    _NOT(enable_otg)
#define AUTO                           _MASK(31) /*!< otg_all -    Auto Return (enable_otg only true when active) */
#define AUTO_                          _NOT(AUTO)
 /* @} */

 /*! @name Timeouts C.f. OTG Table 5-2 A-Device Timing
  * @{
  */
#define Ta_wait_vrise                  _MASK(30) /*!< a_wait_vrise -     Wait for Vbus Rise */
#define Ta_wait_vrise_                 _NOT(Ta_wait_vrise)
#define TA_WAIT_VRISE                  MS(100)
#define Ta_wait_vrise_200              _MASK(30) /*!< a_wait_vrise -     Wait for Vbus Rise */
#define Ta_wait_vrise_200_             _NOT(Ta_wait_vrise_200)
#define TA_WAIT_VRISE_200              MS(200)
#define Ta_wait_vrise_400              _MASK(30) /*!< a_wait_vrise -     Wait for Vbus Rise */
#define Ta_wait_vrise_400_             _NOT(Ta_wait_vrise_400)
#define TA_WAIT_VRISE_400              MS(400)
#define Ta_wait_vrise_500              _MASK(30) /*!< a_wait_vrise -     Wait for Vbus Rise */
#define Ta_wait_vrise_500_             _NOT(Ta_wait_vrise_500)
#define TA_WAIT_VRISE_500              MS(500)
#define Ta_wait_vrise_800              _MASK(30) /*!< a_wait_vrise -     Wait for Vbus Rise */
#define Ta_wait_vrise_800_             _NOT(Ta_wait_vrise_800)
#define TA_WAIT_VRISE_800              MS(800)
#define Ta_bcon_ldb                    _MASK(30) /*!< a_bcon_ldb -     B-Connect Long Debounce */
#define Ta_bcon_ldb_                   _NOT(Ta_bcon_ldb)
#define TA_BCON_LDB                    MS(100)
#define Ta_wait_bcon                   _MASK(30) /*!< a_wait_bcon -     Wait for 1 second for B-Connect */
#define Ta_wait_bcon_                  _NOT(Ta_wait_bcon)
#define TA_WAIT_BCON                   SEC(1)
#define Ta_wait_bcon_5                 _MASK(30) /*!< a_wait_bcon -     Wait for 5 second for B-Connect */
#define Ta_wait_bcon_5_                _NOT(Ta_wait_bcon_5)
#define TA_WAIT_BCON_5                 SEC(5)
#define Ta_wait_bcon_10                _MASK(30) /*!< a_wait_bcon -     Wait for 10 second for B-Connect */
#define Ta_wait_bcon_10_               _NOT(Ta_wait_bcon_10)
#define TA_WAIT_BCON_10                SEC(10)
#define Ta_aidl_bdis                   _MASK(30) /*!< a_hnp_wait -     A-Idle to B-Disconnect */
#define Ta_aidl_bdis_                  _NOT(Ta_aidl_bdis)
#define TA_AIDL_BDIS                   MS(200)
#define Ta_bdis_acon                   _MASK(30) /*!< a_suspend -     B-disconnect to A-Connect */
#define Ta_bdis_acon_                  _NOT(Ta_bdis_acon)
#define TA_BDIS_ACON                   MS(3)
#define Ta_bidl_adis_min               _MASK(30) /*!< a_peripheral -     B-Idle to A-Disconnect minimum (TODO) */
#define Ta_bidl_adis_min_              _NOT(Ta_bidl_adis_min)
#define TA_BIDL_ADIS_MIN               MS(3)
#define Ta_bcon_sdb                    _MASK(30) /*!< a_bcon_sdb -     B-Connect Short Debounce */
#define Ta_bcon_sdb_                   _NOT(Ta_bcon_sdb)
#define TA_BCON_SDB                    US(2)
#define Ta_bcon_sdb_win                _MASK(30) /*!< a_bcon_win -     B-Connect Short Debounce Window */
#define Ta_bcon_sdb_win_               _NOT(Ta_bcon_sdb_win)
#define TA_BCON_SDB_WIN                MS(100)
 /* @} */

 /*! @name Timeouts C.f. OTG Table 5-3 B-Device Timing
  * @{
  */
#define Tb_se0_srp                     _MASK(30) /*!< b_srp_se0 -     SE0 Time Before SRP */
#define Tb_se0_srp_                    _NOT(Tb_se0_srp)
#define TB_SE0_SRP                     MS(2)
#define Tb_data_pls                    _MASK(30) /*!< b_srp_init -     Data-Line Pulse Time */
#define Tb_data_pls_                   _NOT(Tb_data_pls)
#define TB_DATA_PLS                    US(5500)
#define Tb_data_pls_min                _MASK(30) /*!< a_srp_min -     Data-Line Pulse minimum time (5mS-3mSidle) */
#define Tb_data_pls_min_               _NOT(Tb_data_pls_min)
#define TB_DATA_PLS_MIN                MS(4)
#define Tb_data_pls_max                _MASK(30) /*!< a_srp_wait -     Data-Line Pulse maximum time (10mS-3mS idle) */
#define Tb_data_pls_max_               _NOT(Tb_data_pls_max)
#define TB_DATA_PLS_MAX                MS(7)
#define Tb_srp_init                    _MASK(30) /*!< b_srp_init -     SRP Initiate Time (TODO multi-state? Not-needed?) */
#define Tb_srp_init_                   _NOT(Tb_srp_init)
#define TB_SRP_INIT                    MS(100)
#define Tb_srp_fail_min                _MASK(30) /*!< b_srp_wait -     SRP Fail Time minimum (TODO) */
#define Tb_srp_fail_min_               _NOT(Tb_srp_fail_min)
#define TB_SRP_FAIL_MIN                SEC(5)
#define Tb_aidl_bdis_min               _MASK(30) /*!< b_peripheral -     A-idle to B-Disconnect minimum (TODO) */
#define Tb_aidl_bdis_min_              _NOT(Tb_aidl_bdis_min)
#define TB_AIDL_BDIS_MIN               MS(5)
#define Tb_aidl_bdis_max               _MASK(30) /*!< b_peripheral -     A-idle to B-Disconnect maximum (TODO) */
#define Tb_aidl_bdis_max_              _NOT(Tb_aidl_bdis_max)
#define TB_AIDL_BDIS_MAX               MS(150)
#define Tldisc_dschrg                  _MASK(30) /*!< b_dischrg -     Local Disconnect to Data Line Discharge (TODO) */
#define Tldisc_dschrg_                 _NOT(Tldisc_dschrg)
#define TLDISC_DSCHRG                  US(25)
#define Tb_ase0_brst_min               _MASK(30) /*!< b_wait_acon -     A-SE0 to B-Reset minimum */
#define Tb_ase0_brst_min_              _NOT(Tb_ase0_brst_min)
#define TB_ASE0_BRST_MIN               US(3125)
#define Tb_acon_dbnc                   _MASK(30) /*!< b_acon_dbnc -     A-Connect Debounce */
#define Tb_acon_dbnc_                  _NOT(Tb_acon_dbnc)
#define TB_ACON_DBNC                   US(2)
#define Tb_acon_bse0                   _MASK(30) /*!< b_host_se0 -     A-Connect to B-SE0 */
#define Tb_acon_bse0_                  _NOT(Tb_acon_bse0)
#define TB_ACON_BSE0                   MS(1)
#define Tid_ldb                        _MASK(30) /*!< otg_enable -     ID changes debounce */
#define Tid_ldb_                       _NOT(Tid_ldb)
#define TID_LDB                        MS(100)
 /* @} */

 /*! @name Timeouts for Carkit
  * @{
  */
#define Tph_bcon_ldb                   _MASK(30) /*!< ph_init -     B-Connect Long Debounce */
#define Tph_bcon_ldb_                  _NOT(Tph_bcon_ldb)
#define TPH_BCON_LDB                   MS(100)
#define Tph_init_pls                   _MASK(30) /*!< ph_int -     Timeout for Carkit interrupt. */
#define Tph_init_pls_                  _NOT(Tph_init_pls)
#define TPH_INIT_PLS                   US(500)
#define Tcr_uart_rsp                   _MASK(30) /*!< ph_int -     Timeout for Carkit UART */
#define Tcr_uart_rsp_                  _NOT(Tcr_uart_rsp)
#define TCR_UART_RSP                   MS(30)
#define Tcr_aud_det                    _MASK(30) /*!< ph_audio_wait -     Timeout waiting for Carkit Audio ack */
#define Tcr_aud_det_                   _NOT(Tcr_aud_det)
#define TCR_AUD_DET                    US(1000)
#define Tph_led_off                    _MASK(30) /*!< ph_uart -     Timeout for LED off pulse */
#define Tph_led_off_                   _NOT(Tph_led_off)
#define TPH_LED_OFF                    US(10)
#define Tph_led_on                     _MASK(30) /*!< ph_uart -     Timeout for LED on pulse */
#define Tph_led_on_                    _NOT(Tph_led_on)
#define TPH_LED_ON                     MS(4)
#define Tcr_led_off                    _MASK(30) /*!< ph_uart -     Timeout for LED off pulse */
#define Tcr_led_off_                   _NOT(Tcr_led_off)
#define TCR_LED_OFF                    MS(4)
#define Tcr_led_on                     _MASK(30) /*!< ph_uart -     Timeout for LED on pulse */
#define Tcr_led_on_                    _NOT(Tcr_led_on)
#define TCR_LED_ON                     MS(8)
#define Tcr_dm_disc                    _MASK(30) /*!< cr_aud -     Timeout for DM disconnect */
#define Tcr_dm_disc_                   _NOT(Tcr_dm_disc)
#define TCR_DM_DISC                    MS(50)
#define Tph_mono_ack                   _MASK(30) /*!< cr_wait -     Timeout for CR INT */
#define Tph_mono_ack_                  _NOT(Tph_mono_ack)
#define TPH_MONO_ACK                   MS(1)
#define Tph_aud_det                    _MASK(30) /*!< cr_ack -     Timeout for CR ACK */
#define Tph_aud_det_                   _NOT(Tph_aud_det)
#define TPH_AUD_DET                    MS(100)
 /* @} */

 /*! @name Timeouts for timer test
  * @{
  */
#define Tzero                          _MASK(30) /*!< otg_enabled -     Startup */
#define Tzero_                         _NOT(Tzero)
#define TZERO                          MS(2)
#define Tst_100_us                     _MASK(30) /*!< tm_start -     Timer test */
#define Tst_100_us_                    _NOT(Tst_100_us)
#define TST_100_US                     US(100)
#define Tst_one_ms                     _MASK(30) /*!< tm_start -     Timer test */
#define Tst_one_ms_                    _NOT(Tst_one_ms)
#define TST_ONE_MS                     MS(1)
#define Tst_ten_ms                     _MASK(30) /*!< tm_start -     Timer test */
#define Tst_ten_ms_                    _NOT(Tst_ten_ms)
#define TST_TEN_MS                     MS(10)
#define Tst_one_second                 _MASK(30) /*!< tm_start -     Timer test */
#define Tst_one_second_                _NOT(Tst_one_second)
#define TST_ONE_SECOND                 SEC(1)
#define Tst_two_second                 _MASK(30) /*!< tm_start -     Timer test */
#define Tst_two_second_                _NOT(Tst_two_second)
#define TST_TWO_SECOND                 SEC(2)
#define Tst_four_second                _MASK(30) /*!< tm_start -     Timer test */
#define Tst_four_second_               _NOT(Tst_four_second)
#define TST_FOUR_SECOND                SEC(4)
#define Tst_eight_second               _MASK(30) /*!< tm_start -     Timer test */
#define Tst_eight_second_              _NOT(Tst_eight_second)
#define TST_EIGHT_SECOND               SEC(8)
#define Tst_ten_second                 _MASK(30) /*!< tm_start -     Timer test */
#define Tst_ten_second_                _NOT(Tst_ten_second)
#define TST_TEN_SECOND                 SEC(10)
 /* @} */

/* Generated by otg-outputs-h.awk
 *
 * Do not Edit this file.
 */

/* %Z %K */



 /* State Machine Outputs
  */

 /*! @name Driver Initialization Outputs
  * N.B. tcd_en is used for older devices, to check if Vbus
  * already enabled.
  * @{
  */

#define TCD_INIT_OUT                    0        /*!<  Initiate Transceiver Controller Driver Initialization (or De-initialization.) */
#define tcd_init_out                   _setmask(TCD_INIT_OUT)
#define tcd_init_out_                  _resetmask(TCD_INIT_OUT)
#define tcd_init_out_set               _setmask(TCD_INIT_OUT)
#define tcd_init_out_reset             _resetmask(TCD_INIT_OUT)
#define tcd_init_out_power             _powermask(TCD_INIT_OUT)

#define PCD_INIT_OUT                    1        /*!<  Initiate Peripheral Controller Driver Initialization (or De-initialization.) */
#define pcd_init_out                   _setmask(PCD_INIT_OUT)
#define pcd_init_out_                  _resetmask(PCD_INIT_OUT)
#define pcd_init_out_set               _setmask(PCD_INIT_OUT)
#define pcd_init_out_reset             _resetmask(PCD_INIT_OUT)
#define pcd_init_out_power             _powermask(PCD_INIT_OUT)

#define HCD_INIT_OUT                    2        /*!<  Initiate Host Controller Driver Initialization (or De-initialization). */
#define hcd_init_out                   _setmask(HCD_INIT_OUT)
#define hcd_init_out_                  _resetmask(HCD_INIT_OUT)
#define hcd_init_out_set               _setmask(HCD_INIT_OUT)
#define hcd_init_out_reset             _resetmask(HCD_INIT_OUT)
#define hcd_init_out_power             _powermask(HCD_INIT_OUT)

#define OCD_INIT_OUT                    3        /*!<  Initiate OTG Controller Driver Initialization (or De-initialization). */
#define ocd_init_out                   _setmask(OCD_INIT_OUT)
#define ocd_init_out_                  _resetmask(OCD_INIT_OUT)
#define ocd_init_out_set               _setmask(OCD_INIT_OUT)
#define ocd_init_out_reset             _resetmask(OCD_INIT_OUT)
#define ocd_init_out_power             _powermask(OCD_INIT_OUT)

#define TCD_EN_OUT                      4        /*!<  Enable Transceiver Controller Driver */
#define tcd_en_out                     _setmask(TCD_EN_OUT)
#define tcd_en_out_                    _resetmask(TCD_EN_OUT)
#define tcd_en_out_set                 _setmask(TCD_EN_OUT)
#define tcd_en_out_reset               _resetmask(TCD_EN_OUT)
#define tcd_en_out_power               _powermask(TCD_EN_OUT)

#define PCD_EN_OUT                      5        /*!<  Enable Peripheral Controller Driver */
#define pcd_en_out                     _setmask(PCD_EN_OUT)
#define pcd_en_out_                    _resetmask(PCD_EN_OUT)
#define pcd_en_out_set                 _setmask(PCD_EN_OUT)
#define pcd_en_out_reset               _resetmask(PCD_EN_OUT)
#define pcd_en_out_power               _powermask(PCD_EN_OUT)

#define HCD_EN_OUT                      6        /*!<  Enable Host Controller Driver */
#define hcd_en_out                     _setmask(HCD_EN_OUT)
#define hcd_en_out_                    _resetmask(HCD_EN_OUT)
#define hcd_en_out_set                 _setmask(HCD_EN_OUT)
#define hcd_en_out_reset               _resetmask(HCD_EN_OUT)
#define hcd_en_out_power               _powermask(HCD_EN_OUT)
 /* @) */

 /*! @name Transceiver Controller Driver Outputs
  * @{
  */

#define DRV_VBUS_OUT                    7        /*!<  A-Device will Drive Vbus to 5V through charge pump. */
#define drv_vbus_out                   _setmask(DRV_VBUS_OUT)
#define drv_vbus_out_                  _resetmask(DRV_VBUS_OUT)
#define drv_vbus_out_set               _setmask(DRV_VBUS_OUT)
#define drv_vbus_out_reset             _resetmask(DRV_VBUS_OUT)
#define drv_vbus_out_power             _powermask(DRV_VBUS_OUT)

#define CHRG_VBUS_OUT                   8        /*!<  B-Device will charge Vbus to 3.3V through resistor (SRP.) */
#define chrg_vbus_out                  _setmask(CHRG_VBUS_OUT)
#define chrg_vbus_out_                 _resetmask(CHRG_VBUS_OUT)
#define chrg_vbus_out_set              _setmask(CHRG_VBUS_OUT)
#define chrg_vbus_out_reset            _resetmask(CHRG_VBUS_OUT)
#define chrg_vbus_out_power            _powermask(CHRG_VBUS_OUT)

#define DISCHRG_VBUS_OUT                9        /*!<  B-Device will discharge Vbus (enable dischage resistor.) */
#define dischrg_vbus_out               _setmask(DISCHRG_VBUS_OUT)
#define dischrg_vbus_out_              _resetmask(DISCHRG_VBUS_OUT)
#define dischrg_vbus_out_set           _setmask(DISCHRG_VBUS_OUT)
#define dischrg_vbus_out_reset         _resetmask(DISCHRG_VBUS_OUT)
#define dischrg_vbus_out_power         _powermask(DISCHRG_VBUS_OUT)

#define DM_PULLUP_OUT                  10        /*!<  DM pullup control - aka loc_carkit */
#define dm_pullup_out                  _setmask(DM_PULLUP_OUT)
#define dm_pullup_out_                 _resetmask(DM_PULLUP_OUT)
#define dm_pullup_out_set              _setmask(DM_PULLUP_OUT)
#define dm_pullup_out_reset            _resetmask(DM_PULLUP_OUT)
#define dm_pullup_out_power            _powermask(DM_PULLUP_OUT)

#define DM_PULLDOWN_OUT                11        /*!<  DM pulldown control */
#define dm_pulldown_out                _setmask(DM_PULLDOWN_OUT)
#define dm_pulldown_out_               _resetmask(DM_PULLDOWN_OUT)
#define dm_pulldown_out_set            _setmask(DM_PULLDOWN_OUT)
#define dm_pulldown_out_reset          _resetmask(DM_PULLDOWN_OUT)
#define dm_pulldown_out_power          _powermask(DM_PULLDOWN_OUT)

#define DP_PULLUP_OUT                  12        /*!<  DP pullup control - aka loc_conn */
#define dp_pullup_out                  _setmask(DP_PULLUP_OUT)
#define dp_pullup_out_                 _resetmask(DP_PULLUP_OUT)
#define dp_pullup_out_set              _setmask(DP_PULLUP_OUT)
#define dp_pullup_out_reset            _resetmask(DP_PULLUP_OUT)
#define dp_pullup_out_power            _powermask(DP_PULLUP_OUT)

#define DP_PULLDOWN_OUT                13        /*!<  DP pulldown control */
#define dp_pulldown_out                _setmask(DP_PULLDOWN_OUT)
#define dp_pulldown_out_               _resetmask(DP_PULLDOWN_OUT)
#define dp_pulldown_out_set            _setmask(DP_PULLDOWN_OUT)
#define dp_pulldown_out_reset          _resetmask(DP_PULLDOWN_OUT)
#define dp_pulldown_out_power          _powermask(DP_PULLDOWN_OUT)

#define CLR_OVERCURRENT_OUT            14        /*!<  Clear overcurrent indication */
#define clr_overcurrent_out            _setmask(CLR_OVERCURRENT_OUT)
#define clr_overcurrent_out_           _resetmask(CLR_OVERCURRENT_OUT)
#define clr_overcurrent_out_set        _setmask(CLR_OVERCURRENT_OUT)
#define clr_overcurrent_out_reset      _resetmask(CLR_OVERCURRENT_OUT)
#define clr_overcurrent_out_power      _powermask(CLR_OVERCURRENT_OUT)

#define DM_DET_OUT                     15        /*!<  Enable B-Device D- High detect */
#define dm_det_out                     _setmask(DM_DET_OUT)
#define dm_det_out_                    _resetmask(DM_DET_OUT)
#define dm_det_out_set                 _setmask(DM_DET_OUT)
#define dm_det_out_reset               _resetmask(DM_DET_OUT)
#define dm_det_out_power               _powermask(DM_DET_OUT)

#define DP_DET_OUT                     16        /*!<  Enable B-Device D+ High detect */
#define dp_det_out                     _setmask(DP_DET_OUT)
#define dp_det_out_                    _resetmask(DP_DET_OUT)
#define dp_det_out_set                 _setmask(DP_DET_OUT)
#define dp_det_out_reset               _resetmask(DP_DET_OUT)
#define dp_det_out_power               _powermask(DP_DET_OUT)

#define CR_DET_OUT                     17        /*!<  Enable D+ CR detect */
#define cr_det_out                     _setmask(CR_DET_OUT)
#define cr_det_out_                    _resetmask(CR_DET_OUT)
#define cr_det_out_set                 _setmask(CR_DET_OUT)
#define cr_det_out_reset               _resetmask(CR_DET_OUT)
#define cr_det_out_power               _powermask(CR_DET_OUT)

#define CHARGE_PUMP_OUT                18        /*!<  Enable external charge pump. */
#define charge_pump_out                _setmask(CHARGE_PUMP_OUT)
#define charge_pump_out_               _resetmask(CHARGE_PUMP_OUT)
#define charge_pump_out_set            _setmask(CHARGE_PUMP_OUT)
#define charge_pump_out_reset          _resetmask(CHARGE_PUMP_OUT)
#define charge_pump_out_power          _powermask(CHARGE_PUMP_OUT)

#define BDIS_ACON_OUT                  19        /*!<  Enable auto A-connect after B-disconnect. */
#define bdis_acon_out                  _setmask(BDIS_ACON_OUT)
#define bdis_acon_out_                 _resetmask(BDIS_ACON_OUT)
#define bdis_acon_out_set              _setmask(BDIS_ACON_OUT)
#define bdis_acon_out_reset            _resetmask(BDIS_ACON_OUT)
#define bdis_acon_out_power            _powermask(BDIS_ACON_OUT)

#define ID_PULLDOWN_OUT                20        /*!<  Enable the ID to ground pulldown ( (CEA-936 - 5 wire carkit.) */
#define id_pulldown_out                _setmask(ID_PULLDOWN_OUT)
#define id_pulldown_out_               _resetmask(ID_PULLDOWN_OUT)
#define id_pulldown_out_set            _setmask(ID_PULLDOWN_OUT)
#define id_pulldown_out_reset          _resetmask(ID_PULLDOWN_OUT)
#define id_pulldown_out_power          _powermask(ID_PULLDOWN_OUT)

#define UART_OUT                       21        /*!<  Enable Transparent UART mode (CEA-936.) */
#define uart_out                       _setmask(UART_OUT)
#define uart_out_                      _resetmask(UART_OUT)
#define uart_out_set                   _setmask(UART_OUT)
#define uart_out_reset                 _resetmask(UART_OUT)
#define uart_out_power                 _powermask(UART_OUT)

#define AUDIO_OUT                      22        /*!<  Enable Audio mode (CEA-936 CarKit interrupt detector.) */
#define audio_out                      _setmask(AUDIO_OUT)
#define audio_out_                     _resetmask(AUDIO_OUT)
#define audio_out_set                  _setmask(AUDIO_OUT)
#define audio_out_reset                _resetmask(AUDIO_OUT)
#define audio_out_power                _powermask(AUDIO_OUT)

#define MONO_OUT                       23        /*!<  Enable Mono-Audio mode (CEA-936.) */
#define mono_out                       _setmask(MONO_OUT)
#define mono_out_                      _resetmask(MONO_OUT)
#define mono_out_set                   _setmask(MONO_OUT)
#define mono_out_reset                 _resetmask(MONO_OUT)
#define mono_out_power                 _powermask(MONO_OUT)
 /* @) */

 /*! @name Peripheral Controller Driver Outputs
  * @{
  */

#define REMOTE_WAKEUP_OUT              24        /*!<  Peripheral will perform remote wakeup. */
#define remote_wakeup_out              _setmask(REMOTE_WAKEUP_OUT)
#define remote_wakeup_out_             _resetmask(REMOTE_WAKEUP_OUT)
#define remote_wakeup_out_set          _setmask(REMOTE_WAKEUP_OUT)
#define remote_wakeup_out_reset        _resetmask(REMOTE_WAKEUP_OUT)
#define remote_wakeup_out_power        _powermask(REMOTE_WAKEUP_OUT)
 /* @) */

 /*! @name Host Controller Driver Outputs
  * @{
  */

#define HCD_RH_OUT                     25        /*!<  Host will enable root hub */
#define hcd_rh_out                     _setmask(HCD_RH_OUT)
#define hcd_rh_out_                    _resetmask(HCD_RH_OUT)
#define hcd_rh_out_set                 _setmask(HCD_RH_OUT)
#define hcd_rh_out_reset               _resetmask(HCD_RH_OUT)
#define hcd_rh_out_power               _powermask(HCD_RH_OUT)

#define LOC_SOF_OUT                    26        /*!<  Host will enable packet traffic. */
#define loc_sof_out                    _setmask(LOC_SOF_OUT)
#define loc_sof_out_                   _resetmask(LOC_SOF_OUT)
#define loc_sof_out_set                _setmask(LOC_SOF_OUT)
#define loc_sof_out_reset              _resetmask(LOC_SOF_OUT)
#define loc_sof_out_power              _powermask(LOC_SOF_OUT)

#define LOC_SUSPEND_OUT                27        /*!<  Host will suspend bus. */
#define loc_suspend_out                _setmask(LOC_SUSPEND_OUT)
#define loc_suspend_out_               _resetmask(LOC_SUSPEND_OUT)
#define loc_suspend_out_set            _setmask(LOC_SUSPEND_OUT)
#define loc_suspend_out_reset          _resetmask(LOC_SUSPEND_OUT)
#define loc_suspend_out_power          _powermask(LOC_SUSPEND_OUT)

#define REMOTE_WAKEUP_EN_OUT           28        /*!<  Host will send remote wakeup enable or disable request. */
#define remote_wakeup_en_out           _setmask(REMOTE_WAKEUP_EN_OUT)
#define remote_wakeup_en_out_          _resetmask(REMOTE_WAKEUP_EN_OUT)
#define remote_wakeup_en_out_set       _setmask(REMOTE_WAKEUP_EN_OUT)
#define remote_wakeup_en_out_reset     _resetmask(REMOTE_WAKEUP_EN_OUT)
#define remote_wakeup_en_out_power     _powermask(REMOTE_WAKEUP_EN_OUT)

#define HNP_EN_OUT                     29        /*!<  Host will send HNP enable request. */
#define hnp_en_out                     _setmask(HNP_EN_OUT)
#define hnp_en_out_                    _resetmask(HNP_EN_OUT)
#define hnp_en_out_set                 _setmask(HNP_EN_OUT)
#define hnp_en_out_reset               _resetmask(HNP_EN_OUT)
#define hnp_en_out_power               _powermask(HNP_EN_OUT)

#define HPWR_OUT                       30        /*!<  Host will enable high power (external charge pump.) */
#define hpwr_out                       _setmask(HPWR_OUT)
#define hpwr_out_                      _resetmask(HPWR_OUT)
#define hpwr_out_set                   _setmask(HPWR_OUT)
#define hpwr_out_reset                 _resetmask(HPWR_OUT)
#define hpwr_out_power                 _powermask(HPWR_OUT)
 /* @) */
#define MAX_OUTPUTS        31

/* Generated by otg-ioctls-h.awk
 *
 * Do not Edit this file,
 */

/* %Z %K */


#if defined(OTG_LINUX)

#define OTGADMIN_MAGIC              'O'
#define OTGADMIN_VERSION            _IOR(OTGADMIN_MAGIC, 1, u64)
#define OTGADMIN_STATUS             _IOR(OTGADMIN_MAGIC, 3, struct otg_status_update)
#define OTGADMIN_SET_FUNCTION       _IOW(OTGADMIN_MAGIC, 4, struct otg_admin_command)
#define OTGADMIN_GET_FUNCTION       _IOR(OTGADMIN_MAGIC, 4, struct otg_admin_command)
#define OTGADMIN_SET_INFO           _IOW(OTGADMIN_MAGIC, 5, struct otg_firmware_info)
#define OTGADMIN_GET_INFO           _IOR(OTGADMIN_MAGIC, 5, struct otg_firmware_info)
#define OTGADMIN_SET_STATE          _IOW(OTGADMIN_MAGIC, 6, struct otg_state)
#define OTGADMIN_GET_STATE          _IOR(OTGADMIN_MAGIC, 6, struct otg_state)
#define OTGADMIN_SET_TEST           _IOW(OTGADMIN_MAGIC, 7, struct otg_test)
#define OTGADMIN_GET_TEST           _IOR(OTGADMIN_MAGIC, 7, struct otg_test)
#define OTGADMIN_SET_SERIAL         _IOW(OTGADMIN_MAGIC, 8, struct otg_admin_command)
#define OTGADMIN_GET_SERIAL         _IOR(OTGADMIN_MAGIC, 8, struct otg_admin_command)



 /*!
  * Signal Sent: a_bcon_no_tmout_req
  * State Valid: otg_host
  *     Application on A-host wants Ta_wait_bcon timeout disabled (non-OTG mode).
  */
#define OTGADMIN_A_BCON_NO_TMOUT_REQ         _IOW(OTGADMIN_MAGIC, 10, int)

 /*!
  * Signal Sent: a_hpwr_req
  * State Valid: otg_host
  *     Application on A-host wants external charge pump enabled.
  */
#define OTGADMIN_A_HPWR_REQ                  _IOW(OTGADMIN_MAGIC, 11, int)

 /*!
  * Signal Sent: bus_drop
  * State Valid: otg_ok
  *     Application on Device needs to power down bus.
  */
#define OTGADMIN_BUS_DROP                    _IOW(OTGADMIN_MAGIC, 12, int)

 /*!
  * Signal Sent: a_bus_drop
  * State Valid: otg_ok
  *     Application on A-Device needs to power down bus.
  */
#define OTGADMIN_A_BUS_DROP                  _IOW(OTGADMIN_MAGIC, 13, int)

 /*!
  * Signal Sent: b_bus_drop
  * State Valid: otg_ok
  *     Application on B-Device needs to disconnect from bus.
  */
#define OTGADMIN_B_BUS_DROP                  _IOW(OTGADMIN_MAGIC, 14, int)

 /*!
  * Signal Sent: bus_req
  * State Valid: otg_ok
  *     Application on Device wants to use the bus.
  */
#define OTGADMIN_BUS_REQ                     _IOW(OTGADMIN_MAGIC, 15, int)

 /*!
  * Signal Sent: a_bus_req
  * State Valid: otg_ok
  *     Application on A-Device wants to act as host
  */
#define OTGADMIN_A_BUS_REQ                   _IOW(OTGADMIN_MAGIC, 16, int)

 /*!
  * Signal Sent: b_bus_req
  * State Valid: otg_ok
  *     Application on B-Device wants to act as host
  */
#define OTGADMIN_B_BUS_REQ                   _IOW(OTGADMIN_MAGIC, 17, int)

 /*!
  * Signal Sent: b_sess_req
  * State Valid: otg_ok
  *     Application on B-Device to perform SRP (alias for b_srp_req.)
  */
#define OTGADMIN_B_SESS_REQ                  _IOW(OTGADMIN_MAGIC, 18, int)

 /*!
  * Signal Sent: suspend_req
  * State Valid: otg_host
  *     Application on Device requests bus be suspended (alias for a_bus_req/.)
  */
#define OTGADMIN_SUSPEND_REQ                 _IOW(OTGADMIN_MAGIC, 19, int)

 /*!
  * Signal Sent: a_suspend_req
  * State Valid: otg_host
  *     Application on A-host requests bus be suspended (alias for a_bus_req/.)
  */
#define OTGADMIN_A_SUSPEND_REQ               _IOW(OTGADMIN_MAGIC, 20, int)

 /*!
  * Signal Sent: b_suspend_req
  * State Valid: otg_host
  *     Application on B-host requests bus be suspended (alias for b_bus_req/.)
  */
#define OTGADMIN_B_SUSPEND_REQ               _IOW(OTGADMIN_MAGIC, 21, int)

 /*!
  * Signal Sent: set_remote_wakeup_cmd
  * State Valid: a_host
  *     A-Device will send Remote Wakeup Enable Request
  */
#define OTGADMIN_SET_REMOTE_WAKEUP_CMD       _IOW(OTGADMIN_MAGIC, 22, int)

 /*!
  * Signal Sent: remote_wakeup_cmd
  * State Valid: tr_configured
  *     B-Device will perform Remote Wakeup.
  */
#define OTGADMIN_REMOTE_WAKEUP_CMD           _IOW(OTGADMIN_MAGIC, 23, int)

 /*!
  * Signal Sent: reset_remote_wakeup_cmd
  * State Valid: a_host
  *     A-Device will send Remote Wakeup Disable Request
  */
#define OTGADMIN_RESET_REMOTE_WAKEUP_CMD     _IOW(OTGADMIN_MAGIC, 24, int)

 /*!
  * Signal Sent: clr_err_cmd
  * State Valid: a_vbus_err
  *     A-Device ill clears Vbus overcurrent error.
  */
#define OTGADMIN_CLR_ERR_CMD                 _IOW(OTGADMIN_MAGIC, 25, int)

 /*!
  * Signal Sent: b_hnp_cmd
  * State Valid: b_configured
  *     B-Device will attempt HNP
  */
#define OTGADMIN_B_HNP_CMD                   _IOW(OTGADMIN_MAGIC, 26, int)

 /*!
  * Signal Sent: ph_int_cmd
  * State Valid: ph_audio
  *     B-Device will request Carkit interrupt
  */
#define OTGADMIN_PH_INT_CMD                  _IOW(OTGADMIN_MAGIC, 27, int)

 /*!
  * Signal Sent: ph_audio_cmd
  * State Valid: ph_uart
  *     Application on B-Device connected to Carkit requests audio mode.
  */
#define OTGADMIN_PH_AUDIO_CMD                _IOW(OTGADMIN_MAGIC, 28, int)

 /*!
  * Signal Sent: cr_int_cmd
  * State Valid: cr_aud
  *     Application on A-Device wants to emulate Carkit
  */
#define OTGADMIN_CR_INT_CMD                  _IOW(OTGADMIN_MAGIC, 29, int)

 /*!
  * Signal Sent: led_on_cmd
  * State Valid: ph_uart
  *     B-Device will enable Carkit LED
  */
#define OTGADMIN_LED_ON_CMD                  _IOW(OTGADMIN_MAGIC, 30, int)

 /*!
  * Signal Sent: led_off_cmd
  * State Valid: ph_uart
  *     B-Device will disable Carkit LED
  */
#define OTGADMIN_LED_OFF_CMD                 _IOW(OTGADMIN_MAGIC, 31, int)

 /*!
  * Signal Sent: enable_otg
  * State Valid: otg_all
  *     Move State Machine otg_disabled state.
  */
#define OTGADMIN_ENABLE_OTG                  _IOW(OTGADMIN_MAGIC, 32, int)

#define OTGADMIN_MAXNR 33


#endif                          /* defined(OTG_LINUX) */

/* Generated by otg-iocontrol-h.awk
 *
 * Do not Edit this file,
 */

/* %Z %K */


#if defined(OTG_WINCE)

#define OTGADMIN_BASE$              0x401
#define _USBLAN_CTL_CODE(_Function, _Method, _Access) \
        CTL_CODE(OTGADMIN_BASE, _Function, _Method, _Access)

#define OTGADMIN_VERSION            OTGADMIN_CTL_CODE(0x401, METHOD_BUFFERRED, FILE_READ_ACCESS)
#define OTGADMIN_STATUS             OTGADMIN_CTL_CODE(0x403, METHOD_BUFFERRED, FILE_READ_ACCESS)
#define OTGADMIN_SET_FUNCTION       OTGADMIN_CTL_CODE(0x404, METHOD_BUFFERRED, FILE_WRITE_ACCESS)
#define OTGADMIN_GET_FUNCTION       OTGADMIN_CTL_CODE(0x404, METHOD_BUFFERRED, FILE_READ_ACCESS)
#define OTGADMIN_SET_INFO           OTGADMIN_CTL_CODE(0x405, METHOD_BUFFERRED, FILE_WRITE_ACCESS)
#define OTGADMIN_GET_INFO           OTGADMIN_CTL_CODE(0x405, METHOD_BUFFERRED, FILE_READ_ACCESS)
#define OTGADMIN_SET_STATE          OTGADMIN_CTL_CODE(0x406, METHOD_BUFFERRED, FILE_WRITE_ACCESS)
#define OTGADMIN_GET_STATE          OTGADMIN_CTL_CODE(0x406, METHOD_BUFFERRED, FILE_READ_ACCESS)
#define OTGADMIN_SET_TEST           OTGADMIN_CTL_CODE(0x407, METHOD_BUFFERRED, FILE_WRITE_ACCESS)
#define OTGADMIN_GET_TEST           OTGADMIN_CTL_CODE(0x407, METHOD_BUFFERRED, FILE_READ_ACCESS)



 /*!
  * Signal Sent: a_bcon_no_tmout_req
  * State Valid: otg_host
  *     Application on A-host wants Ta_wait_bcon timeout disabled (non-OTG mode).
  */
#define OTGADMIN_A_BCON_NO_TMOUT_REQ         OTGADMIN_CTL_CODE(, 0x40a, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: a_hpwr_req
  * State Valid: otg_host
  *     Application on A-host wants external charge pump enabled.
  */
#define OTGADMIN_A_HPWR_REQ                  OTGADMIN_CTL_CODE(, 0x40b, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: bus_drop
  * State Valid: otg_ok
  *     Application on Device needs to power down bus.
  */
#define OTGADMIN_BUS_DROP                    OTGADMIN_CTL_CODE(, 0x40c, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: a_bus_drop
  * State Valid: otg_ok
  *     Application on A-Device needs to power down bus.
  */
#define OTGADMIN_A_BUS_DROP                  OTGADMIN_CTL_CODE(, 0x40d, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: b_bus_drop
  * State Valid: otg_ok
  *     Application on B-Device needs to disconnect from bus.
  */
#define OTGADMIN_B_BUS_DROP                  OTGADMIN_CTL_CODE(, 0x40e, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: bus_req
  * State Valid: otg_ok
  *     Application on Device wants to use the bus.
  */
#define OTGADMIN_BUS_REQ                     OTGADMIN_CTL_CODE(, 0x40f, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: a_bus_req
  * State Valid: otg_ok
  *     Application on A-Device wants to act as host
  */
#define OTGADMIN_A_BUS_REQ                   OTGADMIN_CTL_CODE(, 0x410, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: b_bus_req
  * State Valid: otg_ok
  *     Application on B-Device wants to act as host
  */
#define OTGADMIN_B_BUS_REQ                   OTGADMIN_CTL_CODE(, 0x411, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: b_sess_req
  * State Valid: otg_ok
  *     Application on B-Device to perform SRP (alias for b_srp_req.)
  */
#define OTGADMIN_B_SESS_REQ                  OTGADMIN_CTL_CODE(, 0x412, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: suspend_req
  * State Valid: otg_host
  *     Application on Device requests bus be suspended (alias for a_bus_req/.)
  */
#define OTGADMIN_SUSPEND_REQ                 OTGADMIN_CTL_CODE(, 0x413, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: a_suspend_req
  * State Valid: otg_host
  *     Application on A-host requests bus be suspended (alias for a_bus_req/.)
  */
#define OTGADMIN_A_SUSPEND_REQ               OTGADMIN_CTL_CODE(, 0x414, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: b_suspend_req
  * State Valid: otg_host
  *     Application on B-host requests bus be suspended (alias for b_bus_req/.)
  */
#define OTGADMIN_B_SUSPEND_REQ               OTGADMIN_CTL_CODE(, 0x415, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: set_remote_wakeup_cmd
  * State Valid: a_host
  *     A-Device will send Remote Wakeup Enable Request
  */
#define OTGADMIN_SET_REMOTE_WAKEUP_CMD       OTGADMIN_CTL_CODE(, 0x416, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: remote_wakeup_cmd
  * State Valid: tr_configured
  *     B-Device will perform Remote Wakeup.
  */
#define OTGADMIN_REMOTE_WAKEUP_CMD           OTGADMIN_CTL_CODE(, 0x417, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: reset_remote_wakeup_cmd
  * State Valid: a_host
  *     A-Device will send Remote Wakeup Disable Request
  */
#define OTGADMIN_RESET_REMOTE_WAKEUP_CMD     OTGADMIN_CTL_CODE(, 0x418, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: clr_err_cmd
  * State Valid: a_vbus_err
  *     A-Device ill clears Vbus overcurrent error.
  */
#define OTGADMIN_CLR_ERR_CMD                 OTGADMIN_CTL_CODE(, 0x419, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: b_hnp_cmd
  * State Valid: b_configured
  *     B-Device will attempt HNP
  */
#define OTGADMIN_B_HNP_CMD                   OTGADMIN_CTL_CODE(, 0x41a, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: ph_int_cmd
  * State Valid: ph_audio
  *     B-Device will request Carkit interrupt
  */
#define OTGADMIN_PH_INT_CMD                  OTGADMIN_CTL_CODE(, 0x41b, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: ph_audio_cmd
  * State Valid: ph_uart
  *     Application on B-Device connected to Carkit requests audio mode.
  */
#define OTGADMIN_PH_AUDIO_CMD                OTGADMIN_CTL_CODE(, 0x41c, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: cr_int_cmd
  * State Valid: cr_aud
  *     Application on A-Device wants to emulate Carkit
  */
#define OTGADMIN_CR_INT_CMD                  OTGADMIN_CTL_CODE(, 0x41d, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: led_on_cmd
  * State Valid: ph_uart
  *     B-Device will enable Carkit LED
  */
#define OTGADMIN_LED_ON_CMD                  OTGADMIN_CTL_CODE(, 0x41e, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: led_off_cmd
  * State Valid: ph_uart
  *     B-Device will disable Carkit LED
  */
#define OTGADMIN_LED_OFF_CMD                 OTGADMIN_CTL_CODE(, 0x41f, METHOD_BUFFERRED, FILE_READ_ACCESS)

 /*!
  * Signal Sent: enable_otg
  * State Valid: otg_all
  *     Move State Machine otg_disabled state.
  */
#define OTGADMIN_ENABLE_OTG                  OTGADMIN_CTL_CODE(, 0x420, METHOD_BUFFERRED, FILE_READ_ACCESS)

#define OTGADMIN_MAXNR 33


#endif                          /* defined(OTG_WINCE) */

/* Generated by otg-metas-h.awk
 *
 * Do not Edit thie file
 */

/* %Z %K */


 /*! @name OTG Figure 6-2 Meta States
  *
  * These are the Meta States defined in the 2.0 OTG Specification
  * Figure 6.2 - Dual-Role A-Device.
  * @{
  */

#define m_a_idle                          0      /*  */

#define m_a_wait_vrise                    1      /*  */

#define m_a_wait_bcon                     2      /*  */

#define m_a_host                          3      /*  */

#define m_a_suspend                       4      /*  */

#define m_a_peripheral                    5      /*  */

#define m_a_wait_vfall                    6      /*  */

#define m_a_vbus_err                      7      /*  */
 /* @} */
 /*! @name OTG Figure 6-3 Meta States
  *
  * These are the Meta States defined in the 2.0 OTG Specification
  * Figure 6.3 - Dual-Role B-Device.
  * @{
  */

#define m_b_idle                          8      /*  */

#define m_b_srp_init                      9      /*  */

#define m_b_peripheral                   10      /*  */

#define m_b_suspend                      11      /*  */

#define m_b_wait_acon                    12      /*  */

#define m_b_host                         13      /*  */

#define m_b_suspended                    14      /*  */
 /* @} */
 /*! @name Carkit Meta States Figure 7-7
  *
  * @{
  */

#define m_ph_disc                        15      /*  Equivalent to b_peripheral */

#define m_ph_init                        16      /*  */

#define m_ph_uart                        17      /*  */

#define m_ph_aud                         18      /*  */

#define m_ph_wait                        19      /*  */

#define m_ph_exit                        20      /*  */

#define m_cr_init                        21      /*  */

#define m_cr_uart                        22      /*  */

#define m_cr_aud                         23      /*  */

#define m_cr_ack                         24      /*  */

#define m_cr_wait                        25      /*  */

#define m_cr_disc                        26      /*  */
 /* @} */
 /*! @name Additional states used locally.
  *
  * @{
  */

#define m_otg_init                       27      /*  */

#define m_usb_accessory                  28      /*  */

#define m_usb_factory                    29      /*  */

#define m_unknown                        30      /*  */
 /* @} */

#define OTG_METAS_FW     31

extern char    *otg_meta_names[];
